<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Worksheet 1, Part 3</title>
    <style>
        canvas {
            width: 640px;
            height: 320px;
            border: 1px solid #333;
            display: block;
            margin: 1rem auto;
        }
    </style>
</head>

<body>
    <h1 style="text-align:center;">Worksheet 1 Â· Part 3</h1>
    <canvas id="gfx" width="640" height="320"></canvas>

    <script defer src="../../common/MV.js"></script>

    <script id="shader-rays" type="x-shader/wgsl">
    struct VSOut {
  @builtin(position) pos : vec4<f32>,
  @location(0) img : vec2<f32>,
};

@vertex
fn vsMain(@builtin(vertex_index) vid : u32) -> VSOut {
  var corners = array<vec2<f32>, 4>(
    vec2<f32>(-1.0, -1.0),
    vec2<f32>( 1.0, -1.0),
    vec2<f32>(-1.0,  1.0),
    vec2<f32>( 1.0,  1.0)
  );
  var out : VSOut;
  let p = corners[vid];
  out.pos = vec4<f32>(p, 0.0, 1.0);
  out.img = p;
  return out;
}

struct Camera {
  eye    : vec4<f32>,
  U      : vec4<f32>,
  V      : vec4<f32>,
  W      : vec4<f32>,
  aspect : f32,
  zoom   : f32,
};
@group(0) @binding(0) var<uniform> cam : Camera;

struct Ray    { origin: vec3<f32>, dir: vec3<f32> };
struct HitInfo { hit: bool, t: f32, color: vec3<f32> };

fn intersectTriangle(ray: Ray,
                     v0: vec3<f32>, v1: vec3<f32>, v2: vec3<f32>,
                     tmin: f32, tmax: f32) -> HitInfo {
  let e0 = v1 - v0;
  let e1 = v2 - v0;
  let n  = cross(e0, e1);

  var q  = dot(ray.dir, n);
  if (abs(q) < 1e-8) {
    return HitInfo(false, tmax, vec3<f32>(0.0));
  }
  q = 1.0 / q;

  let o_to_v0 = v0 - ray.origin;
  let t = dot(o_to_v0, n) * q;
  if (t <= tmin || t >= tmax) {
    return HitInfo(false, tmax, vec3<f32>(0.0));
  }

  let n_tmp = cross(o_to_v0, ray.dir);
  let beta  =  dot(n_tmp, e1) * q;
  if (beta < 0.0) {
    return HitInfo(false, tmax, vec3<f32>(0.0));
  }
  let gamma = -dot(n_tmp, e0) * q;
  if (gamma < 0.0 || beta + gamma > 1.0) {
    return HitInfo(false, tmax, vec3<f32>(0.0));
  }

  return HitInfo(true, t, vec3<f32>(0.4, 0.3, 0.2));
}

fn intersectSphere(ray: Ray,
                   center: vec3<f32>, radius: f32,
                   tmin: f32, tmax: f32) -> HitInfo {
  let oc = ray.origin - center;
  let b = dot(oc, ray.dir);
  let c = dot(oc, oc) - radius * radius;
  let disc = b*b - c;

  if (disc < 0.0) {
    return HitInfo(false, tmax, vec3<f32>(0.0));
  }

  let sqrtD = sqrt(disc);
  var t = -b - sqrtD;
  if (t <= tmin || t >= tmax) {
    t = -b + sqrtD;
    if (t <= tmin || t >= tmax) {
      return HitInfo(false, tmax, vec3<f32>(0.0));
    }
  }

  return HitInfo(true, t, vec3<f32>(0.0, 0.0, 0.0));
}

fn intersectPlane(ray: Ray,
                  p0: vec3<f32>, n: vec3<f32>,
                  tmin: f32, tmax: f32) -> HitInfo {
  let denom = dot(n, ray.dir);
  if (abs(denom) < 1e-6) {
    return HitInfo(false, tmax, vec3<f32>(0.0));
  }
  let t = dot(p0 - ray.origin, n) / denom;
  if (t <= tmin || t >= tmax) {
    return HitInfo(false, tmax, vec3<f32>(0.0));
  }
  return HitInfo(true, t, vec3<f32>(0.1, 0.7, 0.0));
}


@fragment
fn fsMain(@location(0) img : vec2<f32>) -> @location(0) vec4<f32> {
  let center = cam.eye.xyz + cam.zoom * cam.W.xyz;
  let P = center + img.x * cam.U.xyz + (img.y / cam.aspect) * cam.V.xyz;
  let dir = normalize(P - cam.eye.xyz);
  let ray = Ray(cam.eye.xyz, dir);

  var tmax = 1e30;
  let tmin = 1e-4;

  // Triangle
  let v0 = vec3<f32>(-0.2, 0.1,  0.9);
  let v1 = vec3<f32>( 0.2, 0.1,  0.9);
  let v2 = vec3<f32>(-0.2, 0.1, -0.1);

  var hit = intersectTriangle(ray, v0, v1, v2, tmin, tmax);
  var rgb = vec3<f32>(0.1, 0.3, 0.6);   // background (light blue)
  if (hit.hit) {
    tmax = hit.t;
    rgb  = hit.color;
  }

  // Sphere
  let sphCenter = vec3<f32>(0.0, 0.5, 0.0);
  let sphRadius = 0.3;
  let sphHit = intersectSphere(ray, sphCenter, sphRadius, tmin, tmax);
  if (sphHit.hit && sphHit.t < tmax) {
    tmax = sphHit.t;
    rgb  = sphHit.color;
  }


  // Plane
  let plHit = intersectPlane(ray, vec3<f32>(0.0, 0.0, 0.0), vec3<f32>(0.0, 1.0, 0.0), tmin, tmax);
  if (plHit.hit && plHit.t < tmax) { tmax = plHit.t; rgb = plHit.color; }

  return vec4<f32>(rgb, 1.0);
}

  </script>

    <script type="module" src="main.js"></script>
</body>

</html>